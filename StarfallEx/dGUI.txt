--@name dGUI
--@author D.

-- FONTAWESOME
--[[
    Names can be found here: http://fontawesome.io/cheatsheet/
    However due to lua syntax - has to be replaced with _
    Not all icons are present in table below, however using hexadecimal unicode of icon will also work inside lib's functions
]]
if SERVER then return end
FA = {
    glass="f000",
    music="f001",
    envelope_o="f003",
    heart="f004",
    star="f005",
    star_o="f006",
    user="f007",
    film="f008",
    th_large="f009",
    th="f00a",
    th_list="f00b",
    check="f00c",
    times="f00d",
    search_plus="f00e",
    search_minus="f010",
    power_off="f011",
    signal="f012",
    cog="f013",
    trash_o="f014",
    home="f015",
    file_o="f016",
    clock_o="f017",
    road="f018",
    download="f019",
    arrow_circle_o_down="f01a",
    arrow_circle_o_up="f01b",
    inbox="f01c",
    play_circle_o="f01d",
    repeat_="f01e",
    refresh="f021",
    list_alt="f022",
    lock="f023",
    flag="f024",
    headphones="f025",
    volume_off="f026",
    volume_down="f027",
    volume_up="f028",
    qrcode="f029",
    barcode="f02a",
    tag="f02b",
    tags="f02c",
    book="f02d",
    bookmark="f02e",
    print="f02f",
    camera="f030",
    font="f031",
    bold="f032",
    italic="f033",
    text_height="f034",
    text_width="f035",
    align_left="f036",
    align_center="f037",
    align_right="f038",
    align_justify="f039",
    list="f03a",
    outdent="f03b",
    indent="f03c",
    video_camera="f03d",
    picture_o="f03e",
    pencil="f040",
    map_marker="f041",
    adjust="f042",
    tint="f043",
    pencil_square_o="f044",
    share_square_o="f045",
    check_square_o="f046",
    arrows="f047",
    step_backward="f048",
    fast_backward="f049",
    backward="f04a",
    play="f04b",
    pause="f04c",
    stop="f04d",
    forward="f04e",
    fast_forward="f050",
    step_forward="f051",
    eject="f052",
    chevron_left="f053",
    chevron_right="f054",
    plus_circle="f055",
    minus_circle="f056",
    times_circle="f057",
    check_circle="f058",
    question_circle="f059",
    info_circle="f05a",
    crosshairs="f05b",
    times_circle_o="f05c",
    check_circle_o="f05d",
    ban="f05e",
    arrow_left="f060",
    arrow_right="f061",
    arrow_up="f062",
    arrow_down="f063",
    share="f064",
    expand="f065",
    compress="f066",
    plus="f067",
    minus="f068",
    asterisk="f069",
    exclamation_circle="f06a",
    gift="f06b",
    leaf="f06c",
    fire="f06d",
    eye="f06e",
    eye_slash="f070",
    exclamation_triangle="f071",
    plane="f072",
    calendar="f073",
    random="f074",
    comment="f075",
    magnet="f076",
    chevron_up="f077",
    chevron_down="f078",
    retweet="f079",
    shopping_cart="f07a",
    folder="f07b",
    folder_open="f07c",
    arrows_v="f07d",
    arrows_h="f07e",
    bar_chart_o="f080",
    twitter_square="f081",
    facebook_square="f082",
    camera_retro="f083",
    key="f084",
    cogs="f085",
    comments="f086",
    thumbs_o_up="f087",
    thumbs_o_down="f088",
    star_half="f089",
    heart_o="f08a",
    sign_out="f08b",
    linkedin_square="f08c",
    thumb_tack="f08d",
    external_link="f08e",
    sign_in="f090",
    trophy="f091",
    github_square="f092",
    upload="f093",
    lemon_o="f094",
    phone="f095",
    square_o="f096",
    bookmark_o="f097",
    phone_square="f098",
    twitter="f099",
    facebook="f09a",
    github="f09b",
    unlock="f09c",
    credit_card="f09d",
    rss="f09e",
    hdd_o="f0a0",
    bullhorn="f0a1",
    bell="f0f3",
    certificate="f0a3",
    hand_o_right="f0a4",
    hand_o_left="f0a5",
    hand_o_up="f0a6",
    hand_o_down="f0a7",
    arrow_circle_left="f0a8",
    arrow_circle_right="f0a9",
    arrow_circle_up="f0aa",
    arrow_circle_down="f0ab",
    globe="f0ac",
    wrench="f0ad",
    tasks="f0ae",
    filter="f0b0",
    briefcase="f0b1",
    arrows_alt="f0b2",
    users="f0c0",
    link="f0c1",
    cloud="f0c2",
    flask="f0c3",
    scissors="f0c4",
    files_o="f0c5",
    paperclip="f0c6",
    floppy_o="f0c7",
    square="f0c8",
    bars="f0c9",
    list_ul="f0ca",
    list_ol="f0cb",
    strikethrough="f0cc",
    underline="f0cd",
    table="f0ce",
    magic="f0d0",
    truck="f0d1",
    pinterest="f0d2",
    pinterest_square="f0d3",
    google_plus_square="f0d4",
    google_plus="f0d5",
    money="f0d6",
    caret_down="f0d7",
    caret_up="f0d8",
    caret_left="f0d9",
    caret_right="f0da",
    columns="f0db",
    sort="f0dc",
    sort_desc="f0dd",
    sort_asc="f0de",
    envelope="f0e0",
    linkedin="f0e1",
    undo="f0e2",
    gavel="f0e3",
    tachometer="f0e4",
    comment_o="f0e5",
    comments_o="f0e6",
    bolt="f0e7",
    sitemap="f0e8",
    umbrella="f0e9",
    clipboard="f0ea",
    lightbulb_o="f0eb",
    exchange="f0ec",
    cloud_download="f0ed",
    cloud_upload="f0ee",
    user_md="f0f0",
    stethoscope="f0f1",
    suitcase="f0f2",
    bell_o="f0a2",
    coffee="f0f4",
    cutlery="f0f5",
    file_text_o="f0f6",
    building_o="f0f7",
    hospital_o="f0f8",
    ambulance="f0f9",
    medkit="f0fa",
    fighter_jet="f0fb",
    beer="f0fc",
    h_square="f0fd",
    plus_square="f0fe",
    angle_double_left="f100",
    angle_double_right="f101",
    angle_double_up="f102",
    angle_double_down="f103",
    angle_left="f104",
    angle_right="f105",
    angle_up="f106",
    angle_down="f107",
    desktop="f108",
    laptop="f109",
    tablet="f10a",
    mobile="f10b",
    circle_o="f10c",
    quote_left="f10d",
    quote_right="f10e",
    spinner="f110",
    circle="f111",
    reply="f112",
    github_alt="f113",
    folder_o="f114",
    folder_open_o="f115",
    smile_o="f118",
    frown_o="f119",
    meh_o="f11a",
    gamepad="f11b",
    keyboard_o="f11c",
    flag_o="f11d",
    flag_checkered="f11e",
    terminal="f120",
    code="f121",
    reply_all="f122",
    star_half_o="f123",
    location_arrow="f124",
    crop="f125",
    code_fork="f126",
    chain_broken="f127",
    question="f128",
    info="f129",
    exclamation="f12a",
    superscript="f12b",
    subscript="f12c",
    eraser="f12d",
    puzzle_piece="f12e",
    microphone="f130",
    microphone_slash="f131",
    shield="f132",
    calendar_o="f133",
    fire_extinguisher="f134",
    rocket="f135",
    maxcdn="f136",
    chevron_circle_left="f137",
    chevron_circle_right="f138",
    chevron_circle_up="f139",
    chevron_circle_down="f13a",
    html5="f13b",
    css3="f13c",
    anchor="f13d",
    unlock_alt="f13e",
    bullseye="f140",
    ellipsis_h="f141",
    ellipsis_v="f142",
    rss_square="f143",
    play_circle="f144",
    ticket="f145",
    minus_square="f146",
    minus_square_o="f147",
    level_up="f148",
    level_down="f149",
    check_square="f14a",
    pencil_square="f14b",
    external_link_square="f14c",
    share_square="f14d",
    compass="f14e",
    caret_square_o_down="f150",
    caret_square_o_up="f151",
    caret_square_o_right="f152",
    eur="f153",
    gbp="f154",
    usd="f155",
    inr="f156",
    jpy="f157",
    rub="f158",
    krw="f159",
    btc="f15a",
    file="f15b",
    file_text="f15c",
    sort_alpha_asc="f15d",
    sort_alpha_desc="f15e",
    sort_amount_asc="f160",
    sort_amount_desc="f161",
    sort_numeric_asc="f162",
    sort_numeric_desc="f163",
    thumbs_up="f164",
    thumbs_down="f165",
    youtube_square="f166",
    youtube="f167",
    xing="f168",
    xing_square="f169",
    youtube_play="f16a",
    dropbox="f16b",
    stack_overflow="f16c",
    instagram="f16d",
    flickr="f16e",
    adn="f170",
    bitbucket="f171",
    bitbucket_square="f172",
    tumblr="f173",
    tumblr_square="f174",
    long_arrow_down="f175",
    long_arrow_up="f176",
    long_arrow_left="f177",
    long_arrow_right="f178",
    apple="f179",
    windows="f17a",
    android="f17b",
    linux="f17c",
    dribbble="f17d",
    skype="f17e",
    foursquare="f180",
    trello="f181",
    female="f182",
    male="f183",
    gittip="f184",
    sun_o="f185",
    moon_o="f186",
    archive="f187",
    bug="f188",
    vk="f189",
    weibo="f18a",
    renren="f18b",
    pagelines="f18c",
    stack_exchange="f18d",
    arrow_circle_o_right="f18e",
    arrow_circle_o_left="f190",
    caret_square_o_left="f191",
    dot_circle_o="f192",
    wheelchair="f193",
    vimeo_square="f194",
    try="f195",
    plus_square_o="f196",
    space_shuttle="f197",
    slack="f198",
    envelope_square="f199",
    wordpress="f19a",
    openid="f19b",
    university="f19c",
    graduation_cap="f19d",
    yahoo="f19e",
    google="f1a0",
    reddit="f1a1",
    reddit_square="f1a2",
    stumbleupon_circle="f1a3",
    stumbleupon="f1a4",
    delicious="f1a5",
    digg="f1a6",
    pied_piper="f1a7",
    pied_piper_alt="f1a8",
    drupal="f1a9",
    joomla="f1aa",
    language="f1ab",
    fax="f1ac",
    building="f1ad",
    child="f1ae",
    paw="f1b0",
    spoon="f1b1",
    cube="f1b2",
    cubes="f1b3",
    behance="f1b4",
    behance_square="f1b5",
    steam="f1b6",
    steam_square="f1b7",
    recycle="f1b8",
    car="f1b9",
    taxi="f1ba",
    tree="f1bb",
    spotify="f1bc",
    deviantart="f1bd",
    soundcloud="f1be",
    database="f1c0",
    file_pdf_o="f1c1",
    file_word_o="f1c2",
    file_excel_o="f1c3",
    file_powerpoint_o="f1c4",
    file_image_o="f1c5",
    file_archive_o="f1c6",
    file_audio_o="f1c7",
    file_video_o="f1c8",
    file_code_o="f1c9",
    vine="f1ca",
    codepen="f1cb",
    jsfiddle="f1cc",
    life_ring="f1cd",
    circle_o_notch="f1ce",
    rebel="f1d0",
    empire="f1d1",
    git_square="f1d2",
    git="f1d3",
    hacker_news="f1d4",
    tencent_weibo="f1d5",
    qq="f1d6",
    weixin="f1d7",
    paper_plane="f1d8",
    paper_plane_o="f1d9",
    history="f1da",
    circle_thin="f1db",
    header="f1dc",
    paragraph="f1dd",
    sliders="f1de",
    share_alt="f1e0",
    share_alt_square="f1e1",
    bomb="f1e2",
    map="f279",
}
function unichar(c1)
    if type(c1) != "number" then
        c1 = tonumber(c1,16)
    end
    if c1 <= 127 then
        return string.char (c1)
    elseif c1 < 2048 then
        return string.format("%c%c", 192 + math.floor (c1 / 64), 128 + (c1 % 64))
    elseif c1 < 65536 then
        return string.format("%c%c%c", 224 + math.floor (c1 / 4096), 128 + (math.floor (c1 / 64) % 64), 128 + (c1 % 64))
    elseif c1 < 2097152 then
        return string.format("%c%c%c%c", 240 + math.floor (c1 / 262144), 128 + (math.floor (c1 / 4096) % 64), 128 + (math.floor (c1 / 64) % 64), 128 + (c1 % 64))
    end

end

local awesomeFonts = {}

local function getFont(size)
    if not awesomeFonts[size] then
        awesomeFonts[size] = render.createFont("FontAwesome", size, 400, true, false, false, false, false, true)
    end
    return awesomeFonts[size]
end

function render.drawIcon(x, y, icon, size)
    icon = unichar(icon)
    
    render.setFont(getFont(size))
    render.drawText(x, y, icon, 1)
end
-- END FONTAWESOME

--[[
    TODO:

        - Improve Docking!
        - Priorities (BringToFront, MoveBack etc)
        - Grid Layout
        - Ability to set cursorPos manually
]]

--[[
    Changelog:
        - Fixed layouting when objects werent calced/rendered yet
        - registerAttribute function
        - Added docking
        - Fixed major input glitch
]]

DOCK_NONE = 0
DOCK_LEFT = 1
DOCK_RIGHT = 2
DOCK_TOP = 3
DOCK_BOTTOM = 4
DOCK_FILL = 5

local dgui = {
    _DEBUG = false,
    _ENABLE_SCISSOR = true,
    FPS = 300,
    context = {
        curX = 0,
        curY = 0,
        hovered = false,
        pressed = false,
        focused = false,
    },
    Canvas = nil,
    DOCK_NONE = DOCK_NONE,
    DOCK_LEFT = DOCK_LEFT,
    DOCK_RIGHT = DOCK_RIGHT,
    DOCK_TOP = DOCK_TOP,
    DOCK_BOTTOM = DOCK_BOTTOM,
    DOCK_FILL = DOCK_FILL,
}

local dgui_runEvent

local RENDERED_ONCE = false
local INPUT_CAUGHT_LAST_FRAME = false
---------------
------
---------------
local debugFont = render.createFont("Roboto Mono", 20, 400, true)
local defaultFont = render.createFont("Roboto", 40, 500, true)
local keyFont = render.createFont("Roboto", 25, 500, true)

render.createRenderTarget("dgui_buffer")

---------------
------
---------------

local DGUI_CANVAS = nil

local DGUI_CLASSES = {}
local LAYOUT_QUEUE = {}

---------------
------
---------------
local FOCUSED_OBJ = nil
local HOVERED_OBJ = nil
local PRESSED_OBJ = nil

---------------
------
---------------
local UID = 0
local USE_KEY,USE_KEY_NAME = input.lookupBinding("+use")
local lTime = 0
local DELTA_TIME = 0
---------------
------
---------------

--[[ Registers attribute and adds getter/setter if it doesnt exist ]]

local function registerAttribute(tab, name, default)
    local lower = name:sub(1,1):lower()..name:sub(2)
    local upper = name:sub(1,1):upper()..name:sub(2)

    if not tab["set"..upper] then
        tab["set"..upper] = function(self,val) self[lower] = val end
    end

    if not tab["get"..upper] then
        tab["get"..upper] = function(self) return self[lower] end
    end
    tab._fields = tab._fields or {}
    tab._fields[lower] = default
end

--[[ Color*value without changing alpha ]]
local function mc(col,m)
    return Color(col.r * m, col.g * m, col.b * m, a)
end

--[[ Fade between colors ]]
local function mixColor(c1,c2, prog)
    return c1*prog + c2*(1-prog)
end

--[[ Returns true if point x,y is inside box x2,y2,w,h ]]
local function inBox(x, y, x2, y2, w, h)
    return x >= x2 and x <= x2+w and y >= y2 and y <= y2+h
end

--[[ Calls init function of element and it's classe's parents ]]
local function initElement(class,obj)
    local meta = getmetatable(class)

    if meta.__super then
        initElement(meta.__super,obj)
    end
    local fields = rawget(class,"_fields")
    if fields then
        for k,v in pairs(fields) do -- Adding attributes
            obj[k] = v
        end
    end

    if class.init then
	       class.init(obj)
    end
end

local function checkObjectInput(obj)
    local children = obj.children
    if #children > 0 then
        for k = #children, 1, -1 do
            local v = children[k]
            if not v.enabled or not v.catchFocus or not v.visible then continue end
            checkObjectInput(v)
        end
    end

    if not INPUT_CAUGHT_LAST_FRAME then
        if inBox(dgui.cursorX or 0,dgui.cursorY or 0, obj.realX, obj.realY, obj.realWidth, obj.realHeight) then
            HOVERED_OBJ = obj
            INPUT_CAUGHT_LAST_FRAME = true
        end
    end
end



--[[ That function does kinda too much and should be split ]]
local function renderObject(obj, minx, miny, maxx, maxy)
    obj.visible = true
    obj.realX = minx
    obj.realY = miny
    obj.realWidth = maxx - minx
    obj.realHeight = maxy - miny



    if dgui._ENABLE_SCISSOR then
        render.enableScissorRect(minx*2, miny*2, maxx*2, maxy*2)
    end

    render.pushMatrix(obj.matrix,true)
        local w,h = obj.width,obj.height
        obj.width = obj.width * 2
        obj.height = obj.height * 2

        dgui_runEvent(obj, "render")

        obj.width = w
        obj.height = h

    render.popMatrix()

    if dgui._DEBUG then
        render.setColor(Color(255,0,255))
        render.setFont(debugFont)
        local hovertext = HOVERED_OBJ == obj and "\n|HOVERED|" or ""
        local presstext = PRESSED_OBJ == obj and "\n|PRESSED|" or ""
        local dfr = ""
        local postext = obj.x..","..obj.y.."|"
        render.drawText(obj.realX * 2, obj.realY * 2, obj.name..postext..hovertext..presstext..dfr)

        render.setColor(Color(255,0,0))

        render.drawRect(obj.realX * 2, obj.realY * 2, obj.realWidth * 2, 1)
        render.drawRect(obj.realX * 2, obj.realY * 2 + obj.realHeight * 2 -1, obj.realWidth * 2, 1)

        render.drawRect(obj.realX * 2, obj.realY * 2, 1, obj.realHeight * 2)
        render.drawRect(obj.realX * 2 + obj.realWidth * 2 - 1, obj.realY * 2, 1, obj.realHeight * 2)

        render.drawLine(minx*2,miny*2,maxx*2,maxy*2)
    end



    local children = obj.children
    if #children > 0 then
        for k = 1, #children do
            local v = children[k]
            local maxx = maxx
            local maxy = maxy
            local minx = minx
            local miny = miny

            minx = math.max(minx, v.x)
            miny = math.max(miny, v.y)


            maxx = math.min(maxx, v.x + v.width)
            maxy = math.min(maxy, v.y + v.height)

            if not v.enabled then continue end

            if maxx <= minx or maxy <= miny then
                v.visible = false
                continue
            end

            renderObject(v, minx, miny, maxx, maxy)
        end
    end

end


---------------
------
---------------

--[[ Runs event on object (setups context before running function) ]]
function dgui.runEvent(obj, eventName, ...)
    if not obj or not obj.visible or not obj.enabled then return end
    -- Setting up context
    dgui.context.curX = ((dgui.cursorX or 0) - obj.x) * 2
    dgui.context.curY = ((dgui.cursorY or 0) - obj.y) * 2

    dgui.context.hovered = (obj == HOVERED_OBJ)
    dgui.context.pressed = (obj == PRESSED_OBJ)
    dgui.context.focused = (obj == FOCUSED_OBJ)

    if obj[eventName] then
        obj[eventName](obj, ...)
    end
    --

end
dgui_runEvent = dgui.runEvent

--[[ Registers new DGUI class ]]
function dgui.register(name, tab, parent)
    local superclass = DGUI_CLASSES[parent]
    setmetatable(tab, {
        __index = function(self, key)
            if key ~= "constructor" and superclass then
                return superclass[key]
            end
            return nil
        end,
        __super = superclass,
        __tostring = function() return name end
    })


    DGUI_CLASSES[name] = tab
end

local function isValidDGUI(obj)
    return obj.valid
end

--[[ Creates object ]]
function dgui.create(name, parent,debugname)

    local ret = setmetatable({}, {
		      __index = DGUI_CLASSES[name]
	   })
    ret.uid = name.."_"..UID
    UID = UID + 1
    ret.name = debugname or name
    ret.classname = name
    ret.children = {}
    ret.localX = 0
    ret.localY = 0
    ret.x = 0
    ret.y = 0
    ret.hovered = false
    ret.width = 100
    ret.height = 100
    ret.realX = 0
    ret.realY = 0
    ret.realWidth = ret.width
    ret.realHeight = ret.height
    ret.catchFocus = true
    ret.matrix = Matrix()
    ret.enabled = true
    ret.valid = true
    ret.isValid = isValidDGUI
    initElement(DGUI_CLASSES[name], ret)

    ret:setParent(parent)
    return ret

end

--[[ This function should be called in think hook ]]
function dgui.think()
    if not RENDERED_ONCE then return end
    local curX, curY = dgui.cursorX, dgui.cursorY
    curX = curX or 0
    curY = curY or 0

    INPUT_CAUGHT_LAST_FRAME = false -- if it's nil it means we dont need process input anyway, so mark it as processed
    checkObjectInput(DGUI_CANVAS)

    if #LAYOUT_QUEUE > 0 then
        table.sort(LAYOUT_QUEUE,function(a, b)
            return (a.priority or 0) > (b.priority or 0)
        end)
        for k,v in pairs(LAYOUT_QUEUE) do
            dgui_runEvent(v, "doLayout")
            v:fixPos()
            v.shouldPerformLayout  = false
        end
        LAYOUT_QUEUE = {}
    end
end

--[[ Renders UI ]]
function dgui.render()
    dgui.cursorX, dgui.cursorY = render.cursorPos()
    dgui.cursorX = dgui.cursorX or 0
    dgui.cursorY = dgui.cursorY or 0

    DELTA_TIME = timer.curtime() - lTime
    if DELTA_TIME > 1/dgui.FPS then
        render.selectRenderTarget("dgui_buffer")
        render.clear(Color(0,0,0,0))

        renderObject(DGUI_CANVAS, 0,0,512,512)


        render.disableScissorRect()
        render.selectRenderTarget()
        lTime = timer.curtime()

    end


    render.setRenderTargetTexture("dgui_buffer")
    render.setRGBA(255,255,255,255)
    render.drawTexturedRect(0, 0, 512, 512)
    RENDERED_ONCE = true
end

--[[ Lets UI know that key was pressed ]]
function dgui.keyDown(key)
    if key == USE_KEY then
        dgui.setFocusedObject(HOVERED_OBJ)
        PRESSED_OBJ = HOVERED_OBJ
        dgui_runEvent(FOCUSED_OBJ, "onStartUsing")
    end
    dgui_runEvent(FOCUSED_OBJ, "onKeyDown", key)
end

--[[ Lets UI know that key was released]]
function dgui.keyUp(key)

    dgui_runEvent(FOCUSED_OBJ, "onKeyUp", key)

    if key == USE_KEY then
        dgui_runEvent(PRESSED_OBJ, "onStopUsing", key)
        PRESSED_OBJ = nil
    end
end

--[[ Sets current focused object ]]
function dgui.setFocusedObject(obj)
    if FOCUSED_OBJ == obj then return end
    dgui_runEvent(FOCUSED_OBJ, "onLoseFocus")
    FOCUSED_OBJ = obj
    dgui_runEvent(FOCUSED_OBJ, "onFocus")
end

-------------------------
--- Canvas (Internal) ---
-------------------------
--Note: IT'S INTERNAL OBJECT, DONT CREATE IT

local dCanvas = {}
function dCanvas:init()
    self.localX = 0
    self.localY = 0
    self.x = 0
    self.y = 0
    self.width = 512
    self.height = 512
    self.matrix:setTranslation(Vector())
end
function dCanvas:performLayout() end
function dCanvas:setParent() end
dgui.register("_CANVAS_",dCanvas)

dgui.Canvas = dgui.create("_CANVAS_")
DGUI_CANVAS = dgui.Canvas

-------------
--- Panel ---
-------------

local dPanel = {}

function dPanel:init()
    self.dockID = DOCK_NONE
    self.color = Color(11, 11, 11)
end

registerAttribute(dPanel, "color", Color(11, 11, 11))
registerAttribute(dPanel, "enabled", true)


function dPanel:enableInput(enable)
    self.catchFocus = enable
end

function dPanel:dock(id)
    self.dockID = (id >= DOCK_NONE and id <= DOCK_FILL) and id or DOCK_NONE
    self.parent:performLayout()
end

function dPanel:doLayout()
    local topSize = 0
    local bottomSize = 0
    local leftSize = 0
    local rightSize = 0
    local fills = {}

    for k,v in pairs(self.children) do
        local w = v.width
        local h = v.height
        local x = v.localX
        local y = v.localY

        if v.dockID == DOCK_NONE then continue

        elseif v.dockID == DOCK_LEFT then
            x = leftSize
            y = topSize
            h = self.height - topSize-bottomSize
            leftSize = leftSize + w
        elseif v.dockID == DOCK_TOP then
            x = leftSize
            y = topSize
            w = self.width - leftSize-rightSize
            topSize = topSize + h

        elseif v.dockID == DOCK_BOTTOM then
            x = leftSize
            y = self.height - bottomSize - h
            w = self.width - leftSize-rightSize
            bottomSize = bottomSize + h
        elseif v.dockID == DOCK_RIGHT then
            x = self.width - rightSize - w
            y = topSize
            h = self.height - topSize-bottomSize
            leftSize = leftSize + w
        elseif v.dockID == DOCK_FILL then
            table.insert(fills,v)
        end


        v.localX = x
        v.localY = y
        v.width = w
        v.height = h
    end
    for k,v in pairs(fills) do
        v.localX = leftSize
        v.localY = topSize
        v.width = self.width - leftSize - rightSize
        v.height = self.height -topSize - bottomSize
    end

end

function dPanel:performLayout()
    if not self.shouldPerformLayout then
        self.shouldPerformLayout = true
        table.insert(LAYOUT_QUEUE,self)
    end
    for k,v in pairs(self.children) do
        v:performLayout()
    end
end

function dPanel:setPos(x,y) -- Sets position
    self.localX = math.floor(x)
    self.localY =  math.floor(y)
    self:fixPos()

end

function dPanel:getPos(x,y)
    return self.localX,self.localY
end

function dPanel:forceFocus()
    dgui.setFocusedObject(self)
end

function dPanel:setSize(w,h)
    self.width = math.floor(w)
    self.height = math.floor(h)

    if self.parent then
        self.parent:performLayout()
    end
    self:performLayout()
end

function dPanel:getSize()
    return self.width,self.height
end

function dPanel:remove()
    self.valid = false
    for k,v in pairs(self.children) do
        v:remove()
    end
    table.removeByValue(self.parent.children,self)
    table.removeByValue(LAYOUT_QUEUE,self)
end

function dPanel:setParent(parent) -- Sets parent
    if parent == self then
        error("Can't parent to self!")
    end
    parent = parent or DGUI_CANVAS
    if self.parent then
        table.removeByValue(self.parent.children, self)
        self.parent:performLayout(self.parent) -- Old one

    end

    self.parent = parent
    table.insert(parent.children, self)

    parent:performLayout() -- new one

    self:fixPos()

end

function dPanel:fixPos() -- Recalculates global position and position of children

    self.x = self.parent.x + self.localX
    self.y = self.parent.y + self.localY


    self.matrix:setTranslation(Vector(self.x, self.y, 0)*2)

    for k,v in pairs(self.children) do
        v:fixPos()
    end

end

function dPanel:render()
    render.setColor(self.color)
    render.drawRect(0, 0, self.width, self.height)
end

dgui.register("DPanel",dPanel)

-------------------
--- Layout Base ---
-------------------

local dLayoutBase = {}

registerAttribute(dLayoutBase, "expandHorizontal", true)
registerAttribute(dLayoutBase, "expandVertical", true)
registerAttribute(dLayoutBase, "topMargin", 5)
registerAttribute(dLayoutBase, "bottomMargin", 5)
registerAttribute(dLayoutBase, "leftMargin", 5)
registerAttribute(dLayoutBase, "rightMargin", 5)
registerAttribute(dLayoutBase, "verticalSpacing", 5)
registerAttribute(dLayoutBase, "horizontalSpacing", 5)
registerAttribute(dLayoutBase, "topMargin", 5)

function dLayoutBase:setSpacing(m)
    self.verticalSpacing = m
    self.horizontalSpacing = m
end

dgui.register("DLayoutBase", dLayoutBase, "DPanel")

-----------------------
--- Vertical Layout ---
-----------------------

local dVerticalLayout = {}
function dVerticalLayout:doLayout()

    local sumHeight = self.topMargin

    local count = #self.children

    local newHeight = (self.height - self.topMargin - self.bottomMargin + self.verticalSpacing)/count - self.verticalSpacing

    for k,v in pairs(self.children) do
        local height = v.height
        local width = v.width

        if self.expandHorizontal then
            width = self.width - self.leftMargin - self.rightMargin
        end
        if self.expandVertical then
            height = newHeight
        end

        v:setPos(self.leftMargin, sumHeight)

        sumHeight = sumHeight + height + self.verticalSpacing

        v:setSize(width,height)
    end
end

dgui.register("DVerticalLayout", dVerticalLayout, "DLayoutBase")

-------------------------
--- Horizontal Layout ---
-------------------------

local dVerticalLayout = {}
function dVerticalLayout:doLayout()

    local sumWidth = self.leftMargin

    local count = #self.children

    local newWidth = (self.width - self.leftMargin - self.rightMargin + self.horizontalSpacing)/count - self.horizontalSpacing

    for k,v in pairs(self.children) do
        local height = v.height
        local width = v.width

        if self.expandHorizontal then
            width = newWidth
        end
        if self.expandVertical then
            height =  self.height - self.topMargin - self.bottomMargin
        end

        v:setPos(sumWidth, self.topMargin)

        sumWidth = sumWidth + width + self.horizontalSpacing

        v:setSize(width,height)
    end
end

dgui.register("DHorizontalLayout", dVerticalLayout, "DLayoutBase")

-------------
--- Label ---
-------------

local dLabel = {}

function dLabel:init()
    self.catchFocus = false
    render.setFont(self.font)
    self.textwidth,self.textheight = render.getTextSize(self.text)
end

function dLabel:setFont(font)
    self.font = font
    render.setFont(self.font)
    self.textwidth,self.textheight = render.getTextSize(self.text)
end

function dLabel:setText(text)
    self.text = text
    render.setFont(self.font)
    self.textwidth,self.textheight = render.getTextSize(self.text)
end

registerAttribute(dLabel,"font", defaultFont)
registerAttribute(dLabel,"textColor", Color(255, 255, 255))
registerAttribute(dLabel,"alignment", 5)
registerAttribute(dLabel,"text", "Label")


function dLabel:render()

    local w,h = self.width, self.height

    render.setFont(self.font)
    render.setColor(self.textColor)

    if self.alignment == 7 then
        render.drawText(0, 0, self.text, 0)
    elseif self.alignment == 8 then
        render.drawText(w/2, 0, self.text, 1)
    elseif self.alignment == 9 then
        render.drawText(w, 0, self.text, 2)


    elseif self.alignment == 4 then
        render.drawText(0, h/2 - self.textheight/2, self.text, 0)
    elseif self.alignment == 5 then
        render.drawText(w/2, h/2 - self.textheight/2, self.text, 1)
    elseif self.alignment == 6 then
        render.drawText(w, h/2 - self.textheight/2, self.text, 2)


    elseif self.alignment == 1 then
        render.drawText(0, h - self.textheight, self.text, 0)
    elseif self.alignment == 2 then
        render.drawText(w/2, h - self.textheight, self.text, 1)
    elseif self.alignment == 3 then
        render.drawText(w, h - self.textheight, self.text, 2)
    else
        self.alignment = 5
    end


end

dgui.register("DLabel", dLabel, "DPanel")

-------------------
--- Number Wang ---
-------------------

local dNumberWang = {}
dNumberWang.onValueChange = _EMPTYFUNC_

local wangFont = render.createFont("Roboto Mono", 60, 400, true, false, false, false, false, true)

function dNumberWang:init()
    self.color = Color(228, 228, 228)
    self.height = 20
    self.width = 70
    self.catchFocus = true
    self.wholeOnly = false
    self.editMode = false
    self.button = nil
    self.text = tostring(self.value)
end

function dNumberWang:setValue(val)
    self.value = val
    self.value = math.min(self.value, self.max)
    self.value = math.max(self.value, self.min)
    if self.wholeOnly then
        self.value = math.floor(self.value)
    end
    self.text= tostring(self.value)
end

registerAttribute(dNumberWang, "value", 0)
registerAttribute(dNumberWang, "wholeOnly", true)
registerAttribute(dNumberWang, "max", 100)
registerAttribute(dNumberWang, "min", 0)
registerAttribute(dNumberWang, "incrementValue", 1)

function dNumberWang:keyPress(key)
    if tonumber(key) then
        if self.text == "0" then self.text = "" end
        self.text = self.text .. key
    elseif key == "." and not self.text:find("%.") then
        self.text = self.text .. key
    elseif key == "FUNC_RESET" then
        self.text = ""
    elseif key == "backspace" then
        self.text = self.text:sub(1,-2)
    elseif key == "escape" then
        dgui.keypad:close()
         self.editMode = false
    elseif key =="-" and #self.text == 0 then
        self.text = self.text .. key
    elseif key =="enter" then
        if #self.text == 0 then
            self.text = "0"
        end
        self:setValue(tonumber(self.text))
         self.editMode = false
        dgui.keypad:close()
    end
end

function dNumberWang:onStartUsing()
    if self.button == 1 then
        self.value = self.value - self.incrementValue

    elseif self.button == 2 then
        self.value = self.value + self.incrementValue
    else

        dgui.keypad:open(self,function(keypad,key) self:keyPress(key) end, function(keypad) self.editMode = false; self:setValue(self:getValue()) end)
        self.editMode = true
        self.text = ""
    end

    if not self.editMode then
        self.value = math.min(self.value, self.max)
        self.value = math.max(self.value, self.min)

        self.text = tostring(self.value)
        dgui_runEvent(self, "onValueChange", self.value)
    end
end

function dNumberWang:render()
    local context = dgui.context
    local curX,curY = context.curX, context.curY

    self.button = nil
    render.setColor(mc(self.color, 0.3))
    render.drawRect(0, 0, self.height, self.height)

    render.drawRect(self.width-self.height, 0, self.height, self.height)

    render.setColor(self.color)
    render.drawRect(self.height, 0, self.width - self.height * 2, self.height)

    local l = self.height*0.5
    local s = self.height*0.1

    if curX < self.height then
        s = context.hovered and self.height*0.1 + 2 or self.height*0.1
        self.button = 1
    end
    render.drawRect(self.height/2 - l/2, self.height/2 - s/2, l, s)

    if curX > self.width - self.height then
        s = context.hovered and self.height*0.1 + 2 or self.height*0.1
        self.button = 2
    else
        s = self.height*0.1
    end


    render.drawRect(self.width - self.height/2 - l/2, self.height/2 - s/2, l, s)
    render.drawRect(self.width - self.height/2 - s/2, self.height/2 - l/2, s, l)

    render.setFont(self.font)
    render.setColor(mc(self.color, 0.2))

    render.drawText(self.width/2, self.height/2 - self.textheight/2, self.text, 1)

end

dgui.register("DNumberWang", dNumberWang, "DLabel")

--------------
--- Button ---
--------------

local dButton = {}

dButton.doAction = _EMPTYFUNC_

function dButton:init()
    self.catchFocus = true
    self.color = Color(0, 169, 250)
    self.height = 40
    self.barLength = 0
    self.alignment = 1
end

function dButton:onStopUsing()
    local context = dgui.context
    local curX,curY = context.curX, context.curY
end

function dButton:render()
    local context = dgui.context
    local curX,curY = context.curX, context.curY

    local targetlight = 0
    local barLength = self.barLength
    local targetlength = 8

    if context.pressed then
        targetlength = self.width
    elseif context.hovered then
        targetlength = 16
    end

    barLength = math.lerp(DELTA_TIME * 10, barLength, targetlength)

    self.barLength = barLength

    render.setColor(mc(self.color, 0.3))
    render.drawRect(0, 0, self.width, self.height)

    render.setColor(self.color)
    render.drawRect(0, 0, barLength, self.height)


    render.setColor(self.textColor)
    render.setFont(self.font)
    local w,h = render.getTextSize(self.text)
    render.drawText(self.width/2, self.height/2 - h/2, self.text, 1)

end

dgui.register("DButton", dButton, "DLabel")

--------------
--- Slider ---
--------------

local dSlider = {}

dSlider.onValueChange = _EMPTYFUNC_

function dSlider:init()
    self.color = Color(228, 228, 228)
    self.height = 20
    self.progress = 0
end

function dSlider:onStopUsing()
    dgui_runEvent(self, "onValueChange")
end

function dSlider:setValue(v)
    self.progress = (v - self.min)/(self.max-self.min)
end
registerAttribute(dSlider, "value", 0)
registerAttribute(dSlider, "min", 0)
registerAttribute(dSlider, "max", 1)
registerAttribute(dSlider, "progressive", true)
registerAttribute(dSlider, "wholeOnly", false)



function dSlider:render()
    local context = dgui.context
    local curX,curY = context.curX, context.curY


    local s = self.height/4
    local x = curX - s
    local p = x/(self.width - s * 2)

    p = math.max(p, 0)
    p = math.min(p, 1)

    if context.pressed then
        self.progress = p
    end

    self.value = self.min + (self.max - self.min) * self.progress
    if self.whole then self.value = math.round(self.value) end
    self.progress = (self.value - self.min)/(self.max-self.min)

    render.setColor(mc(self.color, 0.8))
    render.drawRect(0, 3, self.width, self.height - 6)

    if self.progressive then
        render.setColor(self.color)
        render.drawRect(0, 3, self.width * self.progress, self.height - 6)
    end

    render.setColor(mc(self.color, 0.3))

    render.drawRect(math.floor((self.width - s * 2) * self.progress), 0, math.floor(self.height - self.height/2), self.height)


end

dgui.register("DSlider", dSlider, "DPanel")

-----------------------
--- Slider Vertical ---
-----------------------

local dSliderVertical = {}

function dSliderVertical:init()
    self.width = 20
    self.height = 100
    self.progressive = false -- Changing the default
end

function dSliderVertical:render(curX, curY)
    local context = dgui.context
    local curX,curY = context.curX, context.curY

    local s = self.width/4
    local y = curY - s
    local p = y/(self.height - s * 2)

    p = math.max(p, 0)
    p = math.min(p, 1)

    if context.pressed then
        self.progress = p
    end

    self.value = self.min + (self.max - self.min) * self.progress
    if self.whole then self.value = math.round(self.value) end
    self.progress = (self.value - self.min)/(self.max-self.min)

    render.setColor(mc(self.color, 0.8))
    render.drawRect(3, 0, self.width -6, self.height)

    if self.progressive then
        render.setColor(self.color)
        render.drawRect(3, 0, self.width -6, self.height * self.progress)
    end

    render.setColor(mc(self.color, 0.3))

    render.drawRect(0, math.floor((self.height - s * 2) * self.progress), self.width, math.floor(self.width - self.width/2))


end

dgui.register("DSliderVertical", dSliderVertical, "DSlider")

----------------
--- Checkbox ---
----------------

local dCheckbox = {}

function dCheckbox:init()
    self.color = Color(0, 169, 250)
    self.offColor = Color(128,128,128)
    self.height = 20
    self.width = 30
    self.animprogress = 0
end

function dCheckbox:onStartUsing()
    self.value = not self.value
    dgui_runEvent(self,"onValueChange",self.value)
end

dCheckbox.onKeyUp = _EMPTYFUNC_

function dCheckbox:render(curX, curY)

    local s = self.height/4

    local p =  self.animprogress

    local target = self.value and 1 or 0

    p = math.lerp(DELTA_TIME*10 , p, target)

    if p > 0.95 then
        p = 1
    end


    self.animprogress = p

    local col = mixColor(self.color,self.offColor,p)

    render.setColor(mc(col, 0.8))
    render.drawRect(0, 3, self.width, self.height - 6)

    render.setColor(col)
    render.drawRect(0, 3, self.width * p, self.height - 6)

    render.setColor(mc(col, 0.3))

    render.drawRect((self.width - s * 2) * p, 0, self.height - self.height/2, self.height)

end

registerAttribute(dCheckbox,"value", false)

dgui.register("DCheckbox",dCheckbox,"DPanel")


--------------
--- Keypad ---
--------------

local dKeypad = {}

local keypad_keys = {
    1,2,3,"-",4,5,6,"C",7,8,9,"X","<",0,".",unichar("2713")
}

function dKeypad:init()
    self.keyColor = Color(228,228,228)
    self.color = Color(32,32,32)
    self.height = 45
    self.width = 34 + 11
    self.font = keyFont
    render.setFont(keyFont)
    local w,h = render.getTextSize("123456789.C")
    self.textheight = h
    self.button = nil
    self.text = "0"
end

function dKeypad:open(obj,onKey,onClose)
    self:setPos(obj.x + obj.width/2, obj.y + obj.height)
    self.editing = obj
    self.onKeypress = onKey
    self.onClose = onClose
    self.enabled = true
    self:forceFocus()
end

function dKeypad:close()
    self.editing = nil
    self.onKeypress = nil
    self.enabled = false
    if self.onClose then self:onClose() end
end


function dKeypad:onStartUsing()
    if self.button then
        local key = tostring(keypad_keys[self.button])
        if key == unichar("2713") then
            key = "enter"
        elseif key == "X" then
            key = "escape"
        elseif key =="<" then
            key = "backspace"
        elseif key =="C" then
            key = "FUNC_RESET"
        end
        dgui_runEvent(self,"onKeypress", key)
    end
end

function dKeypad:onLoseFocus()
    self:close()
end

function dKeypad:render()
    local context = dgui.context
    local curX,curY = dgui.context.curX, dgui.context.curY

    render.setColor(self.color)
    render.drawRect(0, 0, self.width, self.height)
    render.setFont(self.font)

    for I=1, #keypad_keys do
        local x = (I - 1)%4
        local y = math.floor((I - 1)/4)
        if inBox(curX, curY, x * 22 + 2, y * 22 + 2, 20, 20) then
            render.setColor(mc(self.keyColor, 0.5))
            self.button = I
        else
            if keypad_keys[I] == "X" or keypad_keys[I] == unichar("2713") then
                render.setColor(mc(self.keyColor, 0.8))

            else
                render.setColor(self.keyColor)
            end

        end

        render.drawRect(x * 22 + 2, y * 22 + 2, 20, 20)
        render.setColor(self.color)
        render.drawText(x * 22 + 2 + 10, y * 22 + 2 + 10 - self.textheight/2, tostring(keypad_keys[I]), 1)
    end

end

dgui.register("DKeypad",dKeypad,"DPanel")


dgui.keypad = dgui.create("DKeypad")
dgui.keypad.priority = math.huge
dgui.keypad.enabled = false
return dgui
